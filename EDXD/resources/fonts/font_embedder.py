#!/usr/bin/env python3
"""
Generator: read TTF/OTF files from EDXD/resources/fonts and produce
a Python module EDXD/fonts_embedded.py that contains those fonts
as base64 encoded bytes (FONT_FILES dict).

Usage:
  python -m EDXD.font_embedder
It will overwrite EDXD/fonts_embedded.py.
In CI run this before building the binary so the generated module is
included in the packaged artifact.
"""
import base64
import sys
import textwrap
from pathlib import Path

ROOT = Path(__file__).resolve().parent
FONTS_DIR = ROOT / "resources" / "fonts"
OUT_FILE = ROOT / "fonts_embedded.py"

HEADER = '''"""
Generated module containing embedded font files.

This file is generated by EDXD/font_embedder.py and contains a dict
FONT_FILES mapping filename -> base64-encoded bytes.

Do NOT edit by hand; regenerate using the generator script.
"""
import base64
FONT_FILES = {
'''

FOOTER = "}\n"


def encode_font(path: Path) -> str:
    data = path.read_bytes()
    b64 = base64.b64encode(data).decode('ascii')
    # wrap at 76 chars per line for readability
    wrapped = textwrap.fill(b64, width=76)
    return wrapped


def main():
    if not FONTS_DIR.exists():
        print("Fonts directory not found:", FONTS_DIR, file=sys.stderr)
        sys.exit(1)
    entries = []
    for f in sorted(FONTS_DIR.glob("*")):
        if f.suffix.lower() not in (".ttf", ".otf"):
            continue
        print("Embedding", f.name)
        encoded = encode_font(f)
        # generate as a triple-quoted string so large content is OK
        entry = f'    "{f.name}": base64.b64decode("""\\\n{encoded}\\\n"""),\n'
        entries.append(entry)

    out = HEADER + "".join(entries) + FOOTER
    OUT_FILE.write_text(out, encoding="utf-8")
    print("Wrote", OUT_FILE)


if __name__ == "__main__":
    main()
